---
created: 2022-06-19
tags: ABC 曲线 排序 多列排序
subject: 可视化
importance:
skilled:
status:
author:
url: https://www.wolai.com/muxiaoqi/wUSTpUxhp3PMePTbgo7Y63
cover: 
---
https://www.sqlbi.com/articles/rankx-on-multiple-columns-with-dax-and-power-bi/

## 构造数据

```js
Data = 
VAR vNumber = 20
RETURN
GENERATEALL( 
    SELECTCOLUMNS( GENERATESERIES( 1 , vNumber ) , "Index" , [Value] ) , 
    SELECTCOLUMNS( 
        { ( "P" & [Index] , RANDBETWEEN( 1 , 10 ) ) } , 
        "Item" , [Value1] , "Value" , [Value2] 
    ) 
) 
```

## 度量值

```js
积累% 光滑 = 
VAR vTable = 
CALCULATETABLE(
    ADDCOLUMNS(
        ADDCOLUMNS( VALUES( Data[Item] ) , 
            "@Index" , RANKX( VALUES( Data[Item] ) , [Item] ) , 
            "@Value" , CALCULATE( SUM( Data[Value] ) ) 
        ) ,
        "@ValueIndex" , INT( [@Value] ) * COUNTROWS( VALUES( Data[Item] ) ) + [@Index]

    ),
    ALLSELECTED( ) 
)

VAR vValueIndex = SUMX( FILTER( vTable , [Item] = SELECTEDVALUE( Data[Item] ) ) , [@ValueIndex] )


RETURN 
    SUMX( FILTER( vTable , [@ValueIndex] >= vValueIndex ), [@Value] ) / SUMX( vTable , [@Value] )
```

这里和原文不同的是在计算@ValueIndex的时候，文章中给出的并不能完美显示，这里改成了用当前值*总行数再加上当前的索引，这个思想其实SQLBI中按多列排序时也有讲到过，

```js
Ranking Sales and Code =
VAR MaxCustomerCode = MAX ( Customer[Customer Code] )
VAR Result =
    RANKX (
        ALL ( Customer ),
        Customer[Customer Sales] * MaxCustomerCode + Customer[Customer Code]
    )
RETURN
    Result
```

## 原来的写法

![](https://secure2.wostatic.cn/static/pvakxtTg8PAYsk1h24o511/image.png?auth_key=1655636003-2urbJBgyZh4CAumnVZiPrM-0-ac60be31e5a6dfaf8c2a55f147e6b372)